# -*- coding: utf-8 -*-
"""rekomendasi_makanan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nILI0lKwdhNohhq8W8qKqn2wqVPUWWJP

# Proyek Sistem Rekomendasi
- Nama: Leonard Bodhi Kumaro
- Email: bkleonard174@gmail.com
- ID: leonardkumaro

***Perancangan Sistem Pendukung Keputusan Rekomendasi Menu Makanan Pada Penderita Diabetes Mellitus Menggunakan Metode Content-Based Filtering Dan Collaborative Filtering***

## Deskripsi Proyek

Penderita Diabetes Mellitus memerlukan pengaturan pola makan yang ketat guna menjaga kadar gula darah dalam batas normal. Pemilihan menu makanan yang sesuai dengan kebutuhan gizi dan kondisi kesehatan penderita menjadi aspek penting dalam manajemen penyakit ini. Namun, banyak penderita yang mengalami kesulitan dalam menentukan menu makanan yang aman dan sesuai preferensi pribadi. Oleh karena itu, dibutuhkan suatu sistem yang dapat memberikan rekomendasi menu makanan secara cerdas dan adaptif.

Proyek ini bertujuan untuk merancang dan mengembangkan Sistem Pendukung Keputusan Rekomendasi Menu Makanan bagi penderita Diabetes Mellitus dengan memanfaatkan teknik Content-Based Filtering dan Collaborative Filtering. Metode Content-Based Filtering digunakan untuk merekomendasikan menu berdasarkan kandungan gizi makanan dan kebutuhan individu, sedangkan Collaborative Filtering digunakan untuk menyarankan menu berdasarkan preferensi pengguna lain dengan kondisi serupa.

Dataset yang digunakan dalam proyek ini mencakup informasi nutrisi berbagai jenis makanan, seperti kalori, kadar gula, karbohidrat, serat, lemak, kolesterol, protein, sodium, dan kalium, serta data preferensi pengguna terhadap makanan tertentu. Sistem akan membangun profil pengguna berdasarkan riwayat konsumsi dan preferensi makanan yang dianggap aman dan disukai. Dengan menggabungkan kedua pendekatan filtering, sistem diharapkan mampu menghasilkan rekomendasi yang lebih personal, relevan, dan bermanfaat dalam menunjang pengelolaan pola makan penderita diabetes.

Proyek ini diharapkan dapat memberikan kontribusi nyata dalam bidang teknologi kesehatan, khususnya dalam mendukung pengambilan keputusan berbasis data untuk meningkatkan kualitas hidup penderita Diabetes Mellitus melalui asupan makanan yang tepat.

## Business Understanding

Diabetes melitus, khususnya tipe 2, merupakan salah satu penyakit kronis yang paling banyak diderita di seluruh dunia dan menjadi penyebab utama berbagai komplikasi kesehatan seperti penyakit kardiovaskular, gagal ginjal, serta gangguan penglihatan. Salah satu aspek penting dalam pengelolaan diabetes adalah pengaturan pola makan, karena konsumsi makanan yang tidak sesuai dapat menyebabkan lonjakan kadar gula darah yang berbahaya. Oleh karena itu, penentuan asupan makanan yang tepat dan individualistik menjadi kebutuhan mendesak dalam praktik klinis dan gaya hidup penderita diabetes.

## Import Semua Packages/Library yang Digunakan
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from tensorflow import keras
from tensorflow.keras import layers
import tensorflow as tf

"""## Data Understanding

Tahapan Data Understanding merupakan langkah awal dalam proses pengembangan sistem rekomendasi yang bertujuan untuk memahami karakteristik, struktur, serta kualitas data yang akan digunakan. Dalam proyek ini, data yang digunakan mencakup dua komponen utama, yaitu data nutrisi makanan dan data preferensi pengguna.

### Data Loading

Tahapan Data Loading merupakan proses awal dalam siklus pemodelan data yang bertujuan untuk memuat dan mengintegrasikan data mentah ke dalam lingkungan kerja analitik, sehingga siap untuk dilakukan proses pembersihan, eksplorasi, dan pemodelan lebih lanjut. Dalam proyek ini, proses loading mencakup dua sumber data utama, yaitu data nutrisi makanan dan data preferensi pengguna.

| Jenis       | Keterangan                                                       |
|-------------|------------------------------------------------------------------|
| Title       | Rekomendasi Makanan Gizi Anak                                           |
| Source      | [Kaggle](https://www.kaggle.com/datasets/laurenvalentina/rekomendasi-makanan-gizi-anak)                                                           |
| Maintainer  | [Lauren Valentina](https://www.kaggle.com/laurenvalentina)              |
| Visibility  | Publik                                                           |
| Tags        | Gizi, Anak, Makanan, Nutrisi, Rekomendasi                 |
"""

# load the data
foods_df = pd.read_csv('content/preprocessed_dataset.csv')
foods_df.head()

"""Adapun penjelasan dari dataset ini :

File preprocessed_dataset.csv merupakan hasil ekstraksi, pembersihan, dan transformasi data dari dataset asli Rekomendasi Makanan Gizi Anak yang tersedia di platform Kaggle. Meskipun ditujukan untuk kebutuhan gizi anak, dataset ini telah disesuaikan untuk konteks rekomendasi makanan bagi penderita Diabetes Mellitus, dengan mempertimbangkan parameter nutrisi yang relevan seperti kadar gula, karbohidrat, serat, lemak, dan kalori.

| **Nama Kolom**                | **Tipe Data** | **Deskripsi**                                                                                          |
| ----------------------------- | ------------- | ------------------------------------------------------------------------------------------------------ |
| `Id`                          | Numerik       | Nomor identifikasi unik untuk setiap makanan. Digunakan sebagai kunci utama (primary key).             |
| `Nama`                        | Kategorikal   | Nama atau deskripsi dari item makanan. Digunakan sebagai identitas utama dalam sistem rekomendasi.     |
| `Kategori`                    | Kategorikal   | Jenis makanan, misalnya sayur, buah, lauk-pauk, minuman, dll. Digunakan untuk segmentasi.              |
| `Jumlah Porsi`                | Numerik       | Jumlah total porsi yang tersedia atau disarankan untuk konsumsi.                                       |
| `Takaran Porsi`               | Kategorikal   | Ukuran satu porsi (misalnya: 100g, 1 gelas, 1 potong).                                                 |
| `Kalori (kal)`                | Numerik       | Energi total dalam satu porsi makanan, dinyatakan dalam kilokalori (kkal).                             |
| `Lemak (g)`                   | Numerik       | Kandungan total lemak dalam makanan (dalam gram).                                                      |
| `Lemak Jenuh (g)`             | Numerik       | Jumlah lemak jenuh (saturated fat), yang perlu dibatasi karena berpengaruh terhadap kesehatan jantung. |
| `Lemak Tak Jenuh Ganda (g)`   | Numerik       | Lemak sehat yang dapat membantu menurunkan kadar kolesterol LDL (lemak jahat).                         |
| `Lemak Tak Jenuh Tunggal (g)` | Numerik       | Jenis lemak sehat yang mendukung fungsi jantung dan metabolisme.                                       |
| `Kolestrol (g)`               | Numerik       | Kandungan kolesterol dalam makanan (dalam gram). Perlu diperhatikan pada penderita diabetes.           |
| `Protein (g)`                 | Numerik       | Kandungan protein yang berfungsi untuk pemeliharaan dan regenerasi sel tubuh.                          |
| `Karbohidrat (g)`             | Numerik       | Total karbohidrat, termasuk pati, gula, dan serat (dalam gram). Penting untuk pengelolaan glukosa.     |
| `Serat (g)`                   | Numerik       | Kandungan serat pangan, yang membantu memperlambat penyerapan glukosa dan mengontrol gula darah.       |
| `Gula (g)`                    | Numerik       | Kandungan gula sederhana. Harus dibatasi oleh penderita Diabetes Mellitus.                             |
| `Sodium (g)`                  | Numerik       | Kandungan natrium atau garam dalam makanan. Berpengaruh terhadap tekanan darah.                        |
| `Kalium (g)`                  | Numerik       | Kandungan kalium, berperan penting dalam fungsi otot dan jantung.                                      |

### Univariate Exploratory Data Analysis

Univariate EDA bertujuan untuk memahami karakteristik distribusi masing-masing variabel secara individu, baik numerik maupun kategorikal. Tahapan ini penting untuk mengenali penyebaran data, potensi ketidakseimbangan (skewness), dan outlier dalam fitur nutrisi makanan yang digunakan dalam sistem rekomendasi.
"""

plt.figure(figsize=(10, 5))
sns.countplot(data=foods_df, y='Kategori', order=foods_df['Kategori'].value_counts().index, palette='Set2')
plt.title('Distribusi Kategori Makanan')
plt.xlabel('Jumlah')
plt.ylabel('Kategori')
plt.tight_layout()
plt.show()

"""Kategori Dominan:

Sayur merupakan kategori dengan jumlah makanan terbanyak, yakni lebih dari 100 item. Ini menunjukkan bahwa sayuran sangat beragam dalam dataset dan menjadi komponen penting untuk sistem rekomendasi, terutama karena sayuran cenderung rendah kalori dan kaya serat—sangat baik untuk penderita Diabetes Mellitus.

Buah-buahan menempati posisi kedua, menunjukkan bahwa dataset juga kaya akan makanan yang mengandung vitamin, serat, dan gula alami. Namun, perlu dicermati kandungan fruktosa dalam beberapa buah.

Daging dan Ikan & Seafood juga cukup dominan, mencerminkan sumber protein hewani yang beragam dalam dataset.

Kategori dengan Jumlah Rendah:

Kacang-Kacangan, Sup, dan Telur muncul dalam jumlah terbatas. Ini bisa menjadi indikasi bahwa representasi makanan dari kategori ini perlu ditambahkan untuk memperkaya sistem rekomendasi dan meningkatkan variasi.
"""

nutrients = ['Kalori (kal)','Lemak (g)', 'Lemak Jenuh (g)', 'Karbohidrat (g)', 'Gula (g)', 'Serat (g)', 'Protein (g)', 'Sodium (g)', 'Kalium (g)']
plt.figure(figsize=(16, 12))

for i, col in enumerate(nutrients, 1):
    plt.subplot(3, 3, i)
    sns.histplot(foods_df[col], bins=30, kde=True, color='skyblue')
    plt.title(f'Distribusi {col}')
    plt.xlabel(col)
    plt.ylabel('Frekuensi')

plt.tight_layout()
plt.show()

""" Interpretasi Univariate EDA: Fitur Nutrisi

Visualisasi distribusi berikut menggambarkan pola persebaran setiap atribut numerik dalam dataset rekomendasi makanan untuk penderita Diabetes Mellitus.

 1. Kalori (kal)
- Distribusi: Right-skewed (positif skew).
- Mayoritas makanan memiliki kalori antara **50–150 kalori**.
- Outlier: Makanan dengan kalori >400 kalori.
- **Implikasi**: Kalori tinggi perlu dibatasi untuk menjaga berat badan dan kestabilan gula darah.

 2. Lemak (g)
- Distribusi: Sangat skewed ke kanan.
- Mayoritas makanan <10 g lemak.
- Outlier: Lemak >50 g.
- **Implikasi**: Lemak tinggi, terutama lemak jenuh, berisiko meningkatkan resistensi insulin.

 3. Lemak Jenuh (g)
- Distribusi: Mirip dengan lemak total, sangat skewed.
- Sebagian besar makanan mengandung <5 g.
- **Implikasi**: Lemak jenuh perlu dikendalikan karena berhubungan dengan risiko kardiovaskular.

 4. Karbohidrat (g)
- Distribusi: Right-skewed.
- Konsentrasi pada <20 g.
- Outlier: >80 g karbohidrat.
- **Implikasi**: Harus dianalisis lebih lanjut dengan indeks glikemik untuk rekomendasi lebih akurat.

 5. Gula (g)
- Distribusi: Skewed, mayoritas <5 g.
- Outlier: Hingga >60 g.
- **Implikasi**: Gula merupakan parameter kritis yang harus dibatasi pada penderita diabetes.

 6. Serat (g)
- Distribusi: Skewed ke kanan.
- Mayoritas <5 g, outlier hingga >20 g.
- **Implikasi**: Serat tinggi sangat direkomendasikan karena membantu mengontrol glukosa darah.

 7. Protein (g)
- Distribusi: Lebar dan skewed.
- Rentang protein dari <5 g hingga >30 g.
- **Implikasi**: Protein tinggi baik sebagai alternatif sumber energi non-karbohidrat.

 8. Sodium (g)
- Distribusi: Skewed ekstrem ke kanan.
- Mayoritas <500 mg, outlier hingga >1000 mg.
- **Implikasi**: Perlu dikontrol khusus bagi penderita diabetes dengan hipertensi.

 9. Kalium (g)
- Distribusi: Lebih mendekati normal, namun tetap skewed.
- Rentang cukup luas, beberapa makanan mengandung >1000 mg.
- **Implikasi**: Kalium penting untuk menjaga fungsi otot dan tekanan darah.
"""

# Struktur data
print("Jumlah baris dan kolom:", foods_df.shape)

# Nama kolom
print("Nama kolom:", foods_df.columns.tolist())

# Tipe data
print("Tipe data per kolom:\n", foods_df.dtypes)

# Nilai hilang
print("Jumlah nilai hilang:\n", foods_df.isnull().sum())
print("\n")
# Nilai duplikat
print("Jumlah nilai duplikat:", foods_df.duplicated().sum())

"""### Multivariate Exploratory Data Analysis

Analisis eksplorasi multivariat dilakukan untuk memahami hubungan antar fitur numerik dalam dataset makanan berdasarkan nilai gizinya. Tujuan utamanya adalah:

- Mengetahui keterkaitan antar nutrisi.
- Mengidentifikasi fitur-fitur yang saling berkorelasi kuat.
- Menentukan apakah terdapat redundansi informasi atau pola distribusi menarik yang bisa digunakan dalam pemodelan rekomendasi.

Korelasi Antar Fitur Numerik

Korelasi dihitung menggunakan Pearson correlation coefficient dan divisualisasikan dalam bentuk **heatmap**.
"""

# Matriks korelasi dari fitur numerik saja
nutrition = foods_df.select_dtypes(include=[np.number])
# Matriks korelasi
corr = nutrition.corr()
plt.figure(figsize=(10, 8))
sns.heatmap(corr, annot=True, fmt=".2f", cmap='coolwarm', square=True, cbar_kws={"shrink": .8})
plt.title('Matriks Korelasi Fitur Numerik')
plt.show()

"""1. Korelasi Tinggi (r > 0.70)

| Fitur 1               | Fitur 2                      | Nilai Korelasi | Keterangan                                                |
|-----------------------|------------------------------|----------------|------------------------------------------------------------|
| Lemak (g)             | Kalori (kal)                 | 0.81           | Lemak sangat berkontribusi terhadap total kalori.         |
| Lemak Jenuh (g)       | Lemak (g)                    | 0.86           | Lemak jenuh adalah bagian utama dari total lemak.         |
| Lemak Tak Jenuh Ganda | Kalori (kal)                 | 0.59           | Kontribusi terhadap kalori cukup tinggi.                  |
| Gula (g)              | Karbohidrat (g)              | 0.71           | Gula merupakan komponen dari karbohidrat.                 |
| Lemak Tak Jenuh Tunggal | Lemak (g)                  | 0.68           | Lemak tak jenuh tunggal berkontribusi signifikan.         |


 2. Korelasi Sedang (0.40 ≤ r ≤ 0.70)

| Fitur 1         | Fitur 2             | Nilai Korelasi | Keterangan                                               |
|-----------------|----------------------|----------------|-----------------------------------------------------------|
| Kalori (kal)    | Protein (g)          | 0.68           | Protein juga memberikan kontribusi terhadap kalori.       |
| Kolestrol (g)   | Protein (g)          | 0.52           | Makanan tinggi protein umumnya juga mengandung kolestrol. |
| Kalori (kal)    | Karbohidrat (g)      | 0.53           | Karbohidrat ikut menaikkan kalori.                        |
| Kalium (g)      | Kalori (kal)         | 0.53           | Indikasi bahwa makanan tinggi kalori cenderung kaya kalium.|

3. Korelasi Lemah dan Tidak Signifikan

- Fitur seperti **Sodium**, **Serat**, dan **Jumlah Porsi** menunjukkan korelasi rendah dengan hampir semua fitur lainnya.
- Ini mengindikasikan bahwa **Sodium dan Serat** memiliki karakteristik yang independen dan unik dalam komposisi makanan.

4. Korelasi Negatif

- Tidak ada korelasi negatif yang signifikan secara statistik.
- Beberapa fitur menunjukkan korelasi negatif lemah, namun nilainya di bawah ambang signifikansi (|r| < 0.3).

Korelasi ini dapat dimanfaatkan untuk:
- Seleksi fitur penting dalam pemodelan rekomendasi (content-based).
- Menyusun profil nutrisi yang lebih terarah dalam filtering makanan.

## Data Preprocessing

#### Menghapus Kolom yang Tidak Diperlukan
"""

# Menghapus kolom yang tidak diperlukan
foods_df.drop(columns=['Jumlah Porsi', 'Takaran Porsi'], inplace=True)
# Cek kembali struktur data setelah penghapusan kolom
print("\nStruktur data setelah penghapusan kolom tidak diperlukan:\n", foods_df.info())

# Membuat variabel preparation yang berisi dataframe fix_resto kemudian mengurutkan berdasarkan placeID
preparation = foods_df
preparation.sort_values('Nama')

"""#### Mengetahui Jumlah Kategori"""

# Tampilkan katogori unik dari kolom kategori
print("\nKategori unik dari kolom 'Kategori':", preparation['Kategori'].unique())

# ubah nama kategori : buah-buahan menjadi buah, ikan dan seafood menjadi ikan, kacang-kacangan menjadi kacang, snack menjadi camilan
preparation['Kategori'] = preparation['Kategori'].replace({
    'Buah Buahan': 'Buah',
    'Ikan & Seafood': 'Ikan',
    'Kacang Kacangan': 'Kacang',
    'Snack (Makanan Ringan)': 'Camilan'
})

# cek kembali kategori unik
print("\nKategori unik setelah penggantian:", preparation['Kategori'].unique())

"""## Data Preparation"""

# Mengonversi data menjadi dalam bentuk list
nama = preparation['Nama'].tolist()
kategori = preparation['Kategori'].tolist()
kalori = preparation['Kalori (kal)'].tolist()
lemak = preparation['Lemak (g)'].tolist()
lemak_jenuh = preparation['Lemak Jenuh (g)'].tolist()
lemak_takjenuhganda = preparation['Lemak Tak Jenuh Ganda (g)'].tolist()
lemak_takjenuhtunggal = preparation['Lemak Tak Jenuh Tunggal (g)'].tolist()
kolestrol = preparation['Kolestrol (g)'].tolist()
protein = preparation['Protein (g)'].tolist()
karbohidrat = preparation['Karbohidrat (g)'].tolist()
serat = preparation['Serat (g)'].tolist()
gula = preparation['Gula (g)'].tolist()
sodium = preparation['Sodium (g)'].tolist()
kalium = preparation['Kalium (g)'].tolist()
# Menampilkan panjang dari setiap list
print(len(nama))
print(len(kategori))
print(len(kalori))
print(len(lemak))
print(len(lemak_jenuh))
print(len(lemak_takjenuhganda))
print(len(lemak_takjenuhtunggal))
print(len(kolestrol))
print(len(protein))
print(len(karbohidrat))
print(len(serat))
print(len(gula))
print(len(sodium))
print(len(kalium))

# Membuat dictionary untuk data ‘nama’ dan ‘kategori’
foods_new = pd.DataFrame({
    'nama': nama,
    'kategori': kategori,
    'gula': gula
})
foods_new

# Membuat dictionary untuk menyimpan data
all_foods_df = pd.DataFrame({
    'nama': nama,
    'kategori': kategori,
    'gula': gula,
    'karbohidrat': karbohidrat,
    'lemak': lemak,
    'lemak_jenuh': lemak_jenuh,
    'kolestrol': kolestrol,
    'sodium': sodium,
    'kalori': kalori,
    'serat': serat,
    'lemak_takjenuhtunggal': lemak_takjenuhtunggal,
    'lemak_takjenuhganda': lemak_takjenuhganda,
    'protein': protein,
    'kalium': kalium
})

all_foods_df

"""## Modeling

### Model Development Content Based Filtering

Content-Based Filtering (CBF) merupakan pendekatan sistem rekomendasi yang merekomendasikan item berdasarkan kemiripan kontennya dengan preferensi pengguna. Dalam konteks proyek ini, sistem akan merekomendasikan makanan lain yang memiliki profil gizi serupa dengan makanan yang dipilih atau disukai pengguna sebelumnya.
"""

data = foods_new
data.sample(5)

"""#### Ekstraksi Fitur Kategorikal dengan TF-IDF

Dalam pendekatan Content-Based Filtering, tidak hanya fitur numerik yang digunakan, tetapi juga fitur kategorikal seperti kategori makanan. Untuk mengubah teks kategori menjadi representasi numerik yang bisa dihitung kemiripannya, digunakan metode TF-IDF (Term Frequency – Inverse Document Frequency).
"""

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

# Melakukan perhitungan idf pada data kategori'])
tf.fit(data['kategori'])

# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

"""Metode tf.get_feature_names_out() akan menampilkan daftar nama-nama kategori unik yang diekstraksi dari kolom Kategori. Contoh hasilnya bisa seperti berikut:

Tujuan Penggunaan TF-IDF adalah
untuk memperkuat sinyal semantik dari kategori. Misalnya, makanan dalam kategori “Sayur” akan lebih mungkin direkomendasikan bersama dengan makanan lain dalam kategori yang sama.

Untuk mengubah data teks menjadi vektor angka sehingga bisa dihitung menggunakan metrik kesamaan seperti cosine similarity.
"""

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tf.fit_transform(data['kategori'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

"""Mengubah data kategorikal (dalam hal ini kolom kategori) menjadi representasi numerik berbasis TF-IDF agar bisa digunakan dalam sistem rekomendasi berbasis konten (Content-Based Filtering)."""

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

# Membuat dataframe untuk melihat tf-idf matrix
pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=data.nama
).sample(22, axis=1, replace=True).sample(10, axis=0)

"""#### Cosine Similarity

Menghitung tingkat kemiripan antar item (makanan) berdasarkan representasi kategori yang telah dikonversi ke bentuk vektor menggunakan TF-IDF.
"""

from sklearn.metrics.pairwise import cosine_similarity

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama resto
cosine_sim_df = pd.DataFrame(cosine_sim, index=data['nama'], columns=data['nama'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap resto
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Matriks cosine_sim ini dapat digunakan dalam sistem rekomendasi untuk:

- Menemukan makanan yang berkategori mirip satu sama lain.

- Memberikan rekomendasi makanan kepada pengguna berdasarkan makanan yang mereka sukai atau konsumsi sebelumnya.

#### Fungsi foods_recommendations

Memberikan rekomendasi makanan berdasarkan:

- Kemiripan kategori makanan menggunakan cosine similarity dari TF-IDF.

- Kadar gula terendah dari makanan-makanan yang mirip.
"""

def foods_recommendations(nama, similarity_data=cosine_sim_df, items=data[['nama', 'kategori', 'gula']], k=15):
    """
    Rekomendasi makanan berdasarkan kemiripan nama dan kadar gula terendah.

    Parameter:
    -----------
    nama : str
        Nama makanan sebagai referensi.

    similarity_data : pd.DataFrame
        Matriks kemiripan antar nama makanan.

    items : pd.DataFrame
        Data makanan yang memuat setidaknya kolom ['nama', 'kategori', 'gula'].

    k : int
        Jumlah makanan yang direkomendasikan.

    Returns:
    --------
    pd.DataFrame
        Rekomendasi makanan berdasarkan kemiripan dan kadar gula paling rendah.
    """
    if nama not in similarity_data.columns:
        raise ValueError(f"nama '{nama}' tidak ditemukan dalam similarity matrix.")

    # Ambil skor similarity sebagai array
    sim_scores = similarity_data[nama].values

    # Ambil k+1 indeks similarity tertinggi (termasuk dirinya sendiri)
    idx = sim_scores.argsort()[-(k+1):][::-1]
    closest = similarity_data.index[idx].tolist()

    # Hapus dirinya sendiri dari hasil
    closest = [item for item in closest if item != nama]

    # Filter item dari daftar yang mirip
    rekom_item = items[items['nama'].isin(closest)]

    # Urutkan berdasarkan gula paling rendah
    rekom_item = rekom_item.sort_values(by='gula', ascending=True)

    return rekom_item.head(k)

data[data.nama.eq('Alpukat')]

# Mendapatkan rekomendasi nama makanan yang mirip dengan
foods_recommendations('Alpukat')

"""Maka fungsi akan:

- Mencari makanan-makanan lain yang memiliki kategori mirip dengan Alpukat, berdasarkan perhitungan cosine similarity dari TF-IDF kategori.

- Menyaring hasil yang paling mirip (biasanya 10 makanan teratas, bisa diubah lewat parameter k).

- Mengurutkan hasil tersebut berdasarkan kadar gula terendah, karena penderita diabetes sebaiknya menghindari makanan tinggi gula.

- Mengembalikan tabel rekomendasi makanan yang memiliki kategori mirip dengan Alpukat dan paling sehat dilihat dari sisi gula.

#### EVALUASI MODEL
"""

# Jumlah benar dan jumlah total
correct = 15
total = 15

# Menghitung persentase
percentage = (correct / total) * 100

# Menampilkan hasil
print(f"Persentase Presisi: {percentage}%")

"""hasil presisi adalah 15 benar dari 15 didapat dari hasil rekomendasi makanan yang memiliki kategori buah dan semua rekomendasinya memiliki kategori buah

### Collaborative Filtering

Dalam sistem rekomendasi makanan untuk penderita diabetes, tidak hanya penting untuk merekomendasikan makanan yang sesuai selera pengguna, tetapi juga makanan yang memiliki risiko rendah terhadap peningkatan kadar gula darah dan komplikasi diabetes.

Oleh karena itu, perlu ada mekanisme untuk mengukur risiko setiap makanan berdasarkan kandungan nutrisinya, dan menggabungkan informasi ini dalam proses rekomendasi.
"""

df = all_foods_df
df.head(5)

"""Perhitungan Skor Risiko Diabetes Berdasarkan Nutrisi
- Setiap makanan dianalisis berdasarkan komponen nutrisinya seperti gula, karbohidrat, lemak jenuh, kolesterol, sodium, kalori, serat, lemak tak jenuh, protein, dan kalium.

- Setiap komponen diberi bobot sesuai pengaruhnya terhadap risiko diabetes, misalnya gula dan karbohidrat diberi bobot positif karena meningkatkan risiko, sedangkan serat dan lemak tak jenuh diberi bobot negatif karena menurunkan risiko.

- Skor risiko mentah dihitung sebagai jumlah hasil perkalian nilai nutrisi dengan bobotnya.

- Selanjutnya skor risiko ini dinormalisasi ke rentang 0 (risiko rendah) sampai 1 (risiko tinggi) untuk memudahkan interpretasi dan penggunaan.
"""

df = pd.DataFrame(df)

# Bobot sesuai pengaruh terhadap risiko diabetes
w_gula = 0.25
w_karbo = 0.20
w_lemakjenuh = 0.15
w_kolesterol = 0.10
w_sodium = 0.10
w_kalori = 0.10

w_serat = -0.15
w_lemaktakjenuh = -0.10  # gabungan tunggal dan ganda
w_protein = -0.05
w_kalium = -0.05

# Hitung skor risiko mentah
df['skor_risiko_mentah'] = (
    w_gula * df['gula'] +
    w_karbo * df['karbohidrat'] +
    w_lemakjenuh * df['lemak_jenuh'] +
    w_kolesterol * df['kolestrol'] +
    w_sodium * df['sodium'] +
    w_kalori * df['kalori'] +
    w_serat * df['serat'] +
    w_lemaktakjenuh * (df['lemak_takjenuhtunggal'] + df['lemak_takjenuhganda']) +
    w_protein * df['protein'] +
    w_kalium * df['kalium'] / 1000  # skalakan agar sebanding
)

# Normalisasi skor risiko ke rentang 0.00–1.00
scaler = MinMaxScaler()
df['skor_risiko'] = scaler.fit_transform(df[['skor_risiko_mentah']])

# Tampilkan hasil
print(df[['nama', 'kategori', 'skor_risiko']])

# Simpan hasil akhir
skor_df = df[['nama', 'kategori', 'skor_risiko']]

"""Dalam pengolahan data untuk sistem rekomendasi atau model machine learning, data kategorikal seperti nama makanan harus diubah menjadi format numerik agar dapat diproses oleh algoritma. Proses ini dikenal sebagai encoding."""

# Mengubah nama menjadi list tanpa nilai yang sama
nama_ids = df['nama'].unique().tolist()
print('list nama: ', nama_ids)

# Melakukan encoding nama
nama_to_nama_encoded = {x: i for i, x in enumerate(nama_ids)}
print('encoded nama : ', nama_to_nama_encoded)

# Melakukan proses encoding angka ke ke nama
nama_encoded_to_nama = {i: x for i, x in enumerate(nama_ids)}
print('encoded angka ke nama: ', nama_encoded_to_nama)

# Mengubah kategori menjadi list tanpa nilai yang sama
kategori_ids = df['kategori'].unique().tolist()

# Melakukan proses encoding kategori
kategori_to_kategori_encoded = {x: i for i, x in enumerate(kategori_ids)}

# Melakukan proses encoding angka ke kategori
kategori_encoded_to_kategori = {i: x for i, x in enumerate(kategori_ids)}

# Mapping Nama ke dataframe user
df['nama'] = df['nama'].map(nama_to_nama_encoded)

# Mapping Kategori ke dataframe kategori
df['kategori'] = df['kategori'].map(kategori_to_kategori_encoded)

# Mendapatkan jumlah nama
jumlah_nama = len(nama_to_nama_encoded)
print(jumlah_nama)

# Mendapatkan jumlah kategori
jumlah_kategori = len(kategori_encoded_to_kategori)
print(jumlah_kategori)

"""#### Membagi Dataset"""

# Mengacak dataset
df = df.sample(frac=1, random_state=42)
df

# Membuat variabel x untuk mencocokkan data nama dan kategori menjadi satu value
x = df[['nama', 'kategori']].values

# Membuat variabel y untuk membuat rating dari hasil
y = df['skor_risiko'].values

# Membagi menjadi 80% data train dan 20% data validasi
train_indices = int(0.8 * df.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)

print(x, y)

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers

class RecommenderNet(tf.keras.Model):

  # Insialisasi fungsi
  def __init__(self, num_users, num_resto, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_resto = num_resto
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding( # layer embedding user
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_users, 1) # layer embedding user bias
    self.resto_embedding = layers.Embedding( # layer embeddings resto
        num_resto,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.resto_bias = layers.Embedding(num_resto, 1) # layer embedding resto bias

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:,0]) # memanggil layer embedding 1
    user_bias = self.user_bias(inputs[:, 0]) # memanggil layer embedding 2
    resto_vector = self.resto_embedding(inputs[:, 1]) # memanggil layer embedding 3
    resto_bias = self.resto_bias(inputs[:, 1]) # memanggil layer embedding 4

    dot_user_resto = tf.tensordot(user_vector, resto_vector, 2)

    x = dot_user_resto + user_bias + resto_bias

    return tf.nn.sigmoid(x) # activation sigmoid

model = RecommenderNet(jumlah_nama, jumlah_kategori, 100) # inisialisasi model

# model compile
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

# Memulai training

history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 8,
    epochs = 100,
    validation_data = (x_val, y_val)
)

"""#### EVALUASI MODEL"""

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

"""Setelah melakukan pelatihan model, melihat plot metrik RMSE yang menunjukkan kinerja model dalam bentuk grafik. Dari plot tersebut, dapat terlihat bahwa model menghasilkan nilai RMSE sebesar 0.1134 pada train dan 0.2892 pada validation. Angka ini menunjukkan bahwa kinerja model sudah cukup baik, karena nilai RMSE yang lebih rendah menunjukkan kesalahan yang lebih kecil dalam prediksi."""

foods_df = all_foods_df
df = pd.read_csv('content/preprocessed_dataset.csv')

# Mengambil sample nama
nama_id = df.Nama.sample(2).iloc[0]
kategori_visited_by_nama = df[df.Nama == nama_id]

kategori_not_visited = foods_df[~foods_df['nama'].isin(kategori_visited_by_nama.Kategori.values)]['nama']
kategori_not_visited = list(
    set(kategori_not_visited)
    .intersection(set(kategori_to_kategori_encoded.keys()))
)

kategori_not_visited = [[kategori_to_kategori_encoded.get(x)] for x in kategori_not_visited]
nama_encoder = nama_to_nama_encoded.get(nama_id)
nama_kategori_array = np.hstack(
    ([[nama_encoder]] * len(kategori_not_visited), kategori_not_visited)
)

"""Fungsi rekomendasi_makanan dirancang untuk memberikan rekomendasi menu makanan yang disesuaikan dengan tingkat risiko diabetes pasien berdasarkan skor risiko nutrisi dari masing-masing makanan. Fungsi ini menerima tiga parameter utama: probabilitas, yaitu nilai risiko diabetes pasien dalam rentang 0.00 hingga 1.00; skor_df, sebuah DataFrame yang memuat data makanan beserta kategori dan skor risiko masing-masing; serta top_n, jumlah makanan yang akan direkomendasikan pada setiap kategori risiko.

Proses rekomendasi dimulai dengan memisahkan makanan ke dalam dua kelompok berdasarkan perbandingan skor risiko makanan dengan nilai probabilitas risiko pasien. Makanan dengan skor risiko yang lebih rendah dari probabilitas pasien dianggap sebagai makanan aman dan direkomendasikan untuk dikonsumsi, sementara makanan dengan skor risiko lebih tinggi dikategorikan sebagai makanan yang sebaiknya dihindari.

Untuk memberikan variasi dan memperkaya pilihan, fungsi mengambil sampel acak sejumlah top_n makanan dari masing-masing kategori risiko, dengan pengaturan random state agar hasil dapat direproduksi. Hasil rekomendasi kemudian ditampilkan dalam dua bagian: daftar makanan aman yang direkomendasikan dan daftar makanan yang berisiko untuk dihindari.

Dengan pendekatan ini, fungsi menyediakan panduan praktis yang membantu pasien dalam memilih makanan sesuai dengan tingkat risiko diabetes mereka, sekaligus memberikan informasi yang jelas mengenai makanan yang berpotensi memperburuk kondisi. Fungsi ini dapat digunakan sebagai bagian dari sistem pendukung keputusan dalam pengelolaan pola makan penderita diabetes.
"""

def rekomendasi_makanan(probabilitas, skor_df, top_n=5):
    """
    Menampilkan rekomendasi makanan berdasarkan skor risiko nutrisi untuk pasien
    dengan probabilitas risiko diabetes tertentu.

    Parameters:
    - probabilitas : float (0.00–1.00)
    - skor_df : DataFrame yang memiliki kolom ['nama', 'kategori', 'skor_risiko']
    - top_n : int, jumlah makanan yang direkomendasikan untuk masing-masing kategori
    """

    print(f"\n📊 Rekomendasi Makanan untuk Pasien dengan Risiko Diabetes: {probabilitas:.2f}")
    print("=" * 60)

    # Filter makanan aman (skor_risiko < probabilitas)
    makanan_aman = skor_df[skor_df['skor_risiko'] < probabilitas]

    # Filter makanan berisiko (skor_risiko > probabilitas)
    makanan_berisiko = skor_df[skor_df['skor_risiko'] > probabilitas]

    # Ambil secara acak
    makanan_aman_sample = makanan_aman.sample(n=min(top_n, len(makanan_aman)), random_state=42)
    makanan_berisiko_sample = makanan_berisiko.sample(n=min(top_n, len(makanan_berisiko)), random_state=42)

    print("\n🟢 Rekomendasi Makanan Aman:")
    if not makanan_aman_sample.empty:
        for row in makanan_aman_sample.itertuples():
            print(f"• {row.nama} ({row.kategori}) - skor risiko: {row.skor_risiko:.2f}")
    else:
        print("Tidak ada makanan dengan skor risiko yang lebih rendah dari probabilitas.")

    print("\n🔴 Makanan yang Sebaiknya Dihindari:")
    if not makanan_berisiko_sample.empty:
        for row in makanan_berisiko_sample.itertuples():
            print(f"• {row.nama} ({row.kategori}) - skor risiko: {row.skor_risiko:.2f}")
    else:
        print("Tidak ada makanan yang lebih berisiko dari probabilitas.")

"""Pada contoh ini, fungsi rekomendasi_makanan dipanggil dengan nilai probabilitas_pasien sebesar 0.35. Artinya, pasien tersebut memiliki risiko diabetes sekitar 35%. Fungsi akan memproses DataFrame skor_df yang memuat daftar makanan beserta kategori dan skor risiko masing-masing, kemudian memilih makanan yang memiliki skor risiko di bawah 0.35 sebagai makanan yang aman dan layak direkomendasikan untuk dikonsumsi pasien. Sebaliknya, makanan dengan skor risiko di atas 0.35 dianggap berisiko dan disarankan untuk dihindari.

Fungsi akan menampilkan masing-masing hingga 5 makanan acak dari kelompok makanan aman dan berisiko sebagai rekomendasi praktis bagi pasien. Output ini dapat digunakan sebagai panduan dalam memilih menu makanan sehari-hari yang sesuai dengan tingkat risiko diabetes pasien tersebut, sehingga membantu dalam pengelolaan pola makan dan kesehatan secara lebih efektif.
"""

# Misal nilai probabilitas risiko diabetes pasien = 0.35
probabilitas_pasien = 0.35

# Panggil fungsi rekomendasi
rekomendasi_makanan(probabilitas=probabilitas_pasien, skor_df=skor_df, top_n=5)

"""## Kesimpulan

Fungsi rekomendasi_makanan berhasil memberikan rekomendasi menu makanan yang disesuaikan dengan tingkat probabilitas risiko diabetes pasien. Berdasarkan skor risiko nutrisi yang dihitung untuk setiap makanan, fungsi ini memisahkan makanan menjadi dua kategori utama, yaitu makanan yang aman dikonsumsi (dengan skor risiko lebih rendah dari probabilitas pasien) dan makanan yang sebaiknya dihindari (dengan skor risiko lebih tinggi dari probabilitas pasien).

Rekomendasi makanan aman membantu pasien memilih menu yang lebih rendah potensi risikonya terhadap peningkatan diabetes, sementara daftar makanan yang sebaiknya dihindari memberikan informasi tentang pilihan yang perlu diminimalkan atau dieliminasi dari pola makan.

Metode pengambilan sampel acak dari masing-masing kategori menjaga keberagaman pilihan makanan dalam rekomendasi sehingga pasien dapat memiliki opsi yang bervariasi. Dengan demikian, fungsi ini menjadi alat bantu yang efektif dalam mendukung keputusan diet bagi penderita diabetes mellitus, dengan mempertimbangkan profil risiko nutrisi secara personal.
"""